<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>CS184 HW1 - Rasterizer</title>
</head>
<body>
  <h1>Homework 1: Rasterizer</h1>
  <p>Yash Shah — CS184 Spring 2026</p>

  <h2>Task 1: Drawing Single-Color Triangles</h2>

  <h3>Implementation</h3>
  <p>
    To rasterize a triangle, I first compute its axis-aligned bounding box by taking the minimum and maximum
    x and y values across the triangle’s three vertices. I then iterate over all pixels within this box and
    sample at the center of each pixel using (x + 0.5, y + 0.5), as specified in the assignment.
  </p>
  <p>
    For each sample point, I use edge functions to test whether the point lies inside the triangle. If the
    sample is inside the triangle or on its boundary, I fill the pixel with the triangle’s color using
    <code>fill_pixel()</code>.
  </p>

  <h3>Efficiency</h3>
  <p>
    My algorithm only checks pixels inside the triangle’s bounding box rather than scanning the entire framebuffer.
    Each pixel in the bounding box is tested once, so the runtime is proportional to the area of the bounding box.
    This is no worse than a method that checks every sample in the triangle’s bounding box.
  </p>

  <h3>Result (basic/test4.svg + Pixel Inspector)</h3>
  <p>
    The screenshot below was generated using the GUI <code>S</code> hotkey, with the pixel inspector enabled and centered
    on an interesting edge region.
  </p>

  <img src="task1_test4_pixel_inspector.png.png" width="900" />
  
  <h3>Additional Screenshot</h3>
  <img src="task1_test4.png" width="900" />


  <hr>

  <h2>Task 2: Antialiasing by Supersampling</h2>

  <h3>Implementation</h3>

  <p>
  To implement supersampling, I modified the rasterizer to maintain a
  separate supersample buffer (<code>sample_buffer</code>) that stores
  <code>sample_rate</code> color samples per pixel instead of a single
  sample. The buffer size is therefore
  <code>width × height × sample_rate</code>.
  </p>

  <p>
  For triangle rasterization, instead of sampling once at the center
  of each pixel, I subdivide each pixel into a
  <code>sqrt(sample_rate) × sqrt(sample_rate)</code> grid of evenly spaced
  subpixel locations. For each subpixel sample, I perform the same
  edge-function point-in-triangle test used in Task 1.
  If the sample lies inside or on the boundary of the triangle,
  I write the triangle’s color into the corresponding location in
  the supersample buffer.
  </p>

  <p>
  After all primitives are rasterized, I resolve the supersamples
  into the final framebuffer inside
  <code>resolve_to_framebuffer()</code>.
  For each pixel, I average the colors of its
  <code>sample_rate</code> subpixel samples and write the averaged
  result into the RGB framebuffer. This averaging step produces
  partial coverage values near edges, which reduces aliasing artifacts.
  </p>

  <h3>Performance Considerations</h3>

  <p>
  The runtime of the rasterizer increases approximately linearly
  with the sample rate, since each pixel now requires
  <code>sample_rate</code> coverage tests instead of one.
  However, rasterization is still restricted to the triangle’s
  axis-aligned bounding box, so performance remains proportional
  to the bounding box area rather than the entire framebuffer.
  </p>

  <h3>Results (basic/test4.svg)</h3>

  <p><strong>Supersample Rate = 1</strong></p>
  <img src="screenshot_2-24_20-25-13.png" width="900" />

  <p><strong>Supersample Rate = 4</strong></p>
  <img src="screenshot_2-24_20-25-30.png" width="900" />

  <p><strong>Supersample Rate = 16</strong></p>
  <img src="screenshot_2-24_20-26-2.png" width="900" />

  <h3>Analysis</h3>

  <p>
  At a sample rate of 1, triangle edges exhibit visible aliasing
  (stair-step artifacts), especially along shallow or diagonal edges.
  This occurs because each pixel is classified as either fully inside
  or fully outside the triangle.
  </p>

  <p>
  At a sample rate of 4, edge transitions become smoother because
  pixels along boundaries may now have partial coverage. The
  averaged subpixel samples produce intermediate colors that reduce
  the stair-step effect.
  </p>

  <p>
  At a sample rate of 16, edges appear significantly smoother,
  with much finer transitions along triangle boundaries.
  The improvement is especially noticeable along thin or slanted edges,
  where higher sampling density better approximates the true geometric
  coverage of the triangle.
  </p>

  <hr>

  <h3>Extra Credit: Jittered Sampling</h3>

  <p>
  In addition to regular grid supersampling, I implemented jittered
  sampling. Instead of placing subpixel samples at fixed grid locations,
  each sample position is randomly perturbed within its subpixel cell
  using a deterministic hash-based offset. This keeps sampling stable
  between frames while introducing randomness in sample placement.
  </p>

  <p>
  Grid supersampling reduces aliasing but may introduce structured
  patterns along certain edges due to the regular alignment of the grid.
  Jittered sampling breaks this regularity and distributes error more
  randomly, which reduces visible structured artifacts.
  </p>

  <p><strong>Grid Sampling (sample rate = 16)</strong></p>
  <img src="screenshot_2-24_20-31-4.png" width="900" />

  <p><strong>Jittered Sampling (sample rate = 16)</strong></p>
  <img src="screenshot_2-24_20-33-56.png" width="900" />

  <p>
  Compared to regular grid sampling, jittered sampling produces
  less structured stair-step artifacts along diagonal edges.
  While both methods significantly reduce aliasing compared to
  sample rate 1, jittered sampling appears visually smoother
  because the aliasing error is less correlated.
  </p>


  <hr>

  <h2>Task 3: Transforms</h2>

  <h3>Custom Robot (my_robot.svg)</h3>

  <p>
  After implementing the <code>translate</code>, <code>scale</code>, and
  <code>rotate</code> transformation matrices in <code>transforms.cpp</code>,
  the original <code>robot.svg</code> rendered correctly.
  To demonstrate hierarchical transformations, I created a modified
  version of the robot called <code>my_robot.svg</code>.
  </p>

  <p>
  I changed the robot’s color and adjusted several group transforms
  to create a more dynamic pose. The right arm group was rotated
  (using <code>rotate(-40)</code>) to simulate a waving motion.
  The left and right leg groups were rotated in opposite directions
  (<code>rotate(20)</code> and <code>rotate(-20)</code>) to give the appearance
  of running. I also slightly rotated the head to make the pose
  feel more expressive.
  </p>

  <p>
  Because each limb is defined inside a <code>&lt;g&gt;</code> group,
  applying a transformation to the group automatically affects
  all child polygons within that limb. This demonstrates how
  hierarchical transforms propagate through the SVG transformation
  stack via matrix multiplication.
  </p>

  <img src="screenshot_2-24_23-12-33.png" width="900" />

  <hr>
  <h2>Task 4: Barycentric Coordinates</h2>

  <h3>Explanation</h3>
  <p>
  Barycentric coordinates represent any point inside a triangle as a weighted combination
  of the triangle’s three vertices. For a point P inside a triangle with vertices V0, V1,
  and V2, we compute three weights (α, β, γ) such that:
  </p>

  <p>
  P = αV0 + βV1 + γV2, and α + β + γ = 1.
  </p>

  <p>
  Intuitively, each weight measures how close the point is to a vertex. If P is near V0,
  then α is large; if P lies on the edge opposite V0, then α becomes 0. In our rasterizer,
  we compute these weights using edge functions (signed area tests). A point is inside the
  triangle if the weights are all nonnegative (or all nonpositive, depending on winding).
  </p>

  <p>
  Once we have (α, β, γ), we can smoothly interpolate any per-vertex quantity across the
  triangle. For this task, we interpolate color: the final color at P is α·C0 + β·C1 + γ·C2.
  This produces smooth color gradients instead of flat-colored triangles.
  </p>

  <h3>Gradient Example (interpolated colors)</h3>
  <img src="task4_gradient_example.png" width="900" />

  <h3>Color Wheel Result (test7.svg, sample rate 1)</h3>
  <img src="task4_test7.png" width="900" />

  

</body>
</html>
